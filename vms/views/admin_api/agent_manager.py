from flask import Blueprint, render_template, request, jsonify, current_app
from ..check_auth import token_required
import socket
import ssl
import os
from bson.objectid import ObjectId
from bson.errors import InvalidId
import re

bp = Blueprint('agent_manager', __name__, url_prefix='/admin/api/agent_manager/')


def parse_os_info(data):
    lines = data.split('\n')
    info = {}
    for line in lines:
        if line.startswith('NAME='):
            info['name'] = line.split('=')[1].replace('"', '').strip()
        elif line.startswith('VERSION='):
            info['version'] = line.split('=')[1].replace('"', '').strip()
        elif line.startswith('ID='):
            info['id'] = line.split('=')[1].strip()
        elif line.startswith('ID_LIKE='):
            info['id_like'] = line.split('=')[1].strip()
    return info

@bp.route('agent_connect', methods=['POST'])
def agent_connect():
    #TODO: server and client connecting functin
    #1. Get connecting info: OK
    #2. Connecting Test: OK
    #3. Connect Successful OK
    #3.1. mongo DB Insert OK
    #3.2. return Successful OK
    #4. Connect Fail: OK
    #4.1. return Fail: OK
    server_name = request.form.get('server_name')
    # server_name 문자열 길이 검증
    if len(server_name) <= 1 or len(server_name) >= 16:
        return jsonify({"result" : "fail", "message" : "Please provide a server name between 2 to 15 characters."})

    remote_ip = request.form.get('server_ip')
    # remote_ip 유효성 검증
    pattern = r"^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$"
    if not re.match(pattern, remote_ip):
        return jsonify({"result" : "fail", "message" : "The IP address is not valid"})
    
    remote_port = 13469

    current_app.logger.info("Received server_name: %s", server_name)
    current_app.logger.info("Received server_ip: %s", remote_ip)

    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    try:
        BASE_DIR = os.path.dirname(os.path.abspath(__file__))  # This gets the directory of the currently executing script
        CERT_PATH = os.path.join(BASE_DIR, '../../secure_shell_key/cert.pem')
        context.load_verify_locations(CERT_PATH)
    except Exception as e:
        current_app.logger.error(f"Error loading cert file: {e}")
        return jsonify({"result" : "fail", "message" : "Error loading cert file"})

    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            secure_socket = context.wrap_socket(s)
            secure_socket.connect((remote_ip, remote_port))
            secure_socket.sendall(b'CONNECT_TEST')
            data = secure_socket.recv(1024)
            current_app.logger.info("Received: %s",data.decode('utf-8'))
    except Exception as e:
        current_app.logger.error(f"Error connect fail: {e}")
        return jsonify({"result" : "fail", "message" : "Error connect fail"})


    if data.decode('utf-8') == 'CONNECT_SUCCESSFUL':
        #ip_hash = hashlib.sha256(remote_ip.encode('utf-8')).hexdigest()
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                secure_socket = context.wrap_socket(s)
                secure_socket.connect((remote_ip, remote_port))
                secure_socket.sendall(b'GET_INFO')
                remote_info = secure_socket.recv(1024)
                current_app.logger.info("Received: %s",remote_info.decode('utf-8'))
                if remote_info.decode('utf-8') == 'unknown':
                    # remote_info값이 unknown이라면
                    remote_name = 'Unknown'
                    remote_version = 'Unknown'
                    remote_id = 'Unknown'
                    remote_id_like = 'Unknown'
                else:
                    info = parse_os_info(remote_info.decode('utf-8'))
                    remote_name = info.get('name', 'Unknown')
                    remote_version = info.get('version', 'Unknown')
                    remote_id = info.get('id', 'Unknown')
                    remote_id_like = info.get('id_like', 'Unknown')

        except Exception as e:
            current_app.logger.error(f"Error: get info fail: {e}")
            return jsonify({"result" : "fail", "message" : "Error connect fail"})
        
        result = current_app.db.agents.insert_one({'server_ip': remote_ip, 'server_name': server_name, 'remote_name':remote_name, 'remote_version':remote_version,'remote_id':remote_id, 'remote_id_like':remote_id_like})
        if result is not None:
            return jsonify({"result" : "success", "message" : "Connecting Successful"})
        else:
            return jsonify({"result" : "fail", "message": "MongoDB ERROR"})
    else:
        return jsonify({"result" : "fail", "message" : "Connecting Fail"})
    

@bp.route('agents_config', methods=['GET'])
def agents_config():
    agent_id = request.args.get('agent_id')
    current_app.logger.info("agent_id: %s", agent_id)
    
    try:
        agent = current_app.db.agents.find_one({"_id": ObjectId(agent_id)})
        current_app.logger.info("agent: %s", agent)
        if agent:
            # Convert ObjectId to string
            agent['_id'] = str(agent['_id'])
            return jsonify(agent)
        else:
            return jsonify({"error": "Agent not found", "error_code":"404"}), 404
    except InvalidId:
        return jsonify({"error": "Invalid agent ID format", "error_code":"400"}), 400

@bp.route('agents_config_save', methods=['POST'])
def agents_config_save():
    # 1. Post data receive
    agent_id = request.form.get('agent_id')
    server_name = request.form.get('server_name')
    if len(server_name) <= 1 or len(server_name) >= 31:
        return jsonify({"result" : "fail", "message" : "Please provide a server name between 2 to 30 characters."})
    
    server_ip = request.form.get('server_ip')
    remote_id_like = request.form.get('remote_id_like')
    remote_id = request.form.get('remote_id')
    remote_version = request.form.get('remote_version')

    # 2. Update MongoDB
    current_app.logger.debug("agents_config_save agent_id: %s",agent_id)
    result = current_app.db.agents.update_one(
        {"_id": ObjectId(agent_id)},
        {"$set": {
            "server_name": server_name,
            "server_ip": server_ip,
            "remote_id_like": remote_id_like,
            "remote_id": remote_id,
            "remote_version": remote_version
        }}
    )
    current_app.logger.info("result: %s",result)
    # 3. return success or fail message
    if result.modified_count > 0:
        return jsonify({"result": "success", "message": "Agent data updated successfully!"})
    else:
        return jsonify({"result": "fail", "message": "Failed to update agent data."})


@bp.route('get_script_names', methods=['GET'])
def get_script_names():
    base_path = "Vulnerability_Check_Script"
    os_types = ["CentOS", "Fedora", "Rocky", "Ubuntu"]

    script_names = []

    try:
        for os_type in os_types:
            for script_name in os.listdir(os.path.join(base_path, os_type)):
                script_names.append({"name": script_name, "os_type": os_type})

        return jsonify(script_names)

    except Exception as e:
        return jsonify({"error": str(e)}), 500



@bp.route('send_script', methods=['POST'])
def send_script():
    script_name = request.form.get('script_name')
    os_type = request.form.get('os_type')  # Getting the OS type
    agent_id = request.form.get('agent_id')
    current_app.logger.debug("Script Name: %s", script_name)
    current_app.logger.debug("OS Type: %s", os_type)
    current_app.logger.debug("Agent _id: %s", agent_id)

    # MongoDB에서 해당 agent의 IP 주소를 가져옵니다.
    agent_entry = current_app.db.agents.find_one({"_id": ObjectId(agent_id)})
    if not agent_entry:
        return jsonify({"result": "error", "message": "Agent not found in the database"})
    agent_ip = agent_entry['server_ip']

    script_directory = os.path.join('Vulnerability_Check_Script', os_type)  # Modify this to your script directory
    script_path = os.path.join(script_directory, script_name)

    # SSL context setup
    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
    CERT_PATH = os.path.join(BASE_DIR, '../../secure_shell_key/cert.pem')
    context.load_verify_locations(CERT_PATH)

    # File sending logic starts here
    try:
        with socket.create_connection((agent_ip, 13469)) as s:
            with context.wrap_socket(s, server_side=False) as secure_conn:
                secure_conn.sendall(b'SEND_SCRIPT')
                file_size = os.path.getsize(script_path)
                secure_conn.sendall(str(file_size).encode('utf-8'))
                if secure_conn.recv(1024) == b'READY':
                    with open(script_path, 'rb') as f:
                        while True:
                            data = f.read(4096)
                            if not data:
                                break
                            secure_conn.sendall(data)
                    if secure_conn.recv(1024) == b'SUCCESS':
                        return jsonify({"result": "success", "message": "Script sent successfully!"})
                    else:
                        return jsonify({"result": "error", "message": "Failed to send script."})
                else:
                    return jsonify({"result": "error", "message": "Agent did not respond."})
    except Exception as e:
        current_app.logger.error(f"Error while sending script: {e}")
        return jsonify({"result": "error", "message": f"Exception encountered: {e}"})
        