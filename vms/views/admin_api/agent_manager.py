from flask import Blueprint, request, jsonify, current_app
from ..check_auth import token_required
import socket, os
from bson.objectid import ObjectId
from bson.errors import InvalidId
from .utils import is_valid_ip, create_ssl_context, parse_os_info

bp = Blueprint('agent_manager', __name__, url_prefix='/admin/api/agent_manager/')
socket_port = 13469

@bp.route('agent_connect', methods=['POST']) # /admin/api/agent_manager/agent_connect
def agent_connect():
    """ Remote서버에서 실행중인 Agent와 연결 """

    server_name = request.form.get('server_name')

    # Check valid server name
    if len(server_name) <= 1 or len(server_name) >= 31:
        return jsonify({"result" : "fail", "message" : "Please provide a server name between 2 to 30 characters."})

    remote_ip = request.form.get('server_ip')

    # Check valid ip
    if not is_valid_ip(remote_ip): #defined utils.py
        return jsonify({"result" : "fail", "message" : "The IP address is not valid"})
    
    """ Debugging info
    current_app.logger.debug("Received server_name: %s", server_name)
    current_app.logger.debug("Received server_ip: %s", remote_ip)
    """

    # Create ssl context
    context, error_message = create_ssl_context() #defined utils.py
    if error_message:
        """ Debugging info
        current_app.logger.error(error_message)
        """
        return jsonify({"result" : "fail", "message" : "Error loading cert file"})

    # Send 'CONNECT_TEST' to agent
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)
            secure_socket = context.wrap_socket(s)
            secure_socket.connect((remote_ip, socket_port))
            secure_socket.sendall(b'CONNECT_TEST')
            data = secure_socket.recv(1024)
            """ Debugging info
            current_app.logger.debug("Received: %s",data.decode('utf-8'))
            """
    except Exception as e:
        """ Debugging info
        current_app.logger.error(f"Error connect fail: {e}")
        """
        return jsonify({"result" : "fail", "message" : "Error connect fail"})


    # If connect successful send 'GET_INFO' to agent
    if data.decode('utf-8') == 'CONNECT_SUCCESSFUL':
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                secure_socket = context.wrap_socket(s)
                secure_socket.connect((remote_ip, socket_port))
                secure_socket.sendall(b'GET_INFO')
                remote_info = secure_socket.recv(1024)
                """ Debugging info
                current_app.logger.debug("Received: %s",remote_info.decode('utf-8'))
                """

                # If recv message is 'unknown' then save unknown to os info
                if remote_info.decode('utf-8') == 'unknown':
                    remote_name = 'Unknown'
                    remote_version = 'Unknown'
                    remote_id = 'Unknown'
                    remote_id_like = 'Unknown'

                # If recv message in not 'unknown' then save os info
                else:
                    info = parse_os_info(remote_info.decode('utf-8'))
                    remote_name = info.get('name', 'Unknown')
                    remote_version = info.get('version', 'Unknown')
                    remote_id = info.get('id', 'Unknown')
                    remote_id_like = info.get('id_like', 'Unknown')

        # If an error occurs in the GET_INFO
        except Exception as e:
            """ Debugging info
            current_app.logger.error(f"Error: get info fail: {e}")
            """
            return jsonify({"result" : "fail", "message" : "Error connect fail"})
        
        # Insert os info in mongodb.agents
        result = current_app.db.agents.insert_one({'server_ip': remote_ip, 'server_name': server_name, 'remote_name':remote_name, 'remote_version':remote_version,'remote_id':remote_id, 'remote_id_like':remote_id_like})
        
        # If an successful in the insert mongodb
        if result is not None:
            return jsonify({"result" : "success", "message" : "Connecting Successful"})
        
        # If an error occurs in the insert mongodb
        else:
            return jsonify({"result" : "fail", "message": "MongoDB ERROR"})
        
    # If 'CONNECT_TEST' is successful, But not received 'CONNECT_SUCCESSFUL'
    else:
        return jsonify({"result" : "fail", "message" : "Connecting Fail"})
    

@bp.route('agents_config', methods=['GET']) # /admin/api/agent_manager/agents_config
def agents_config():
    """ Remote server의 정보를 리턴 """

    agent_id = request.args.get('agent_id')
    """ Debugging info
    current_app.logger.debug("agent_id: %s", agent_id)
    """
    
    try:
        # Find agent_id in mongodb.agents
        agent = current_app.db.agents.find_one({"_id": ObjectId(agent_id)})
        """ Debugging info
        current_app.logger.debug("agent: %s", agent)
        """

        # If agent is exist
        if agent:

            # Convert ObjectId to string
            agent['_id'] = str(agent['_id'])
            return jsonify(agent)
        
        # If agent is not exist
        else:
            return jsonify({"error": "Agent not found", "error_code":"404"}), 404
        
    # If invalid agent id format
    except InvalidId:
        return jsonify({"error": "Invalid agent ID format", "error_code":"400"}), 400

@bp.route('agents_config_save', methods=['POST']) # /admin/api/agent_manager/agent_config_save
def agents_config_save():
    """ 변경된 Remote server의 정보를 저장 """

    agent_id = request.form.get('agent_id')
    server_name = request.form.get('server_name')

    # Verifying server_name Length
    if len(server_name) <= 1 or len(server_name) >= 31:
        return jsonify({"result" : "fail", "message" : "Please provide a server name between 2 to 30 characters."})
    
    server_ip = request.form.get('server_ip')
    remote_id_like = request.form.get('remote_id_like')
    remote_id = request.form.get('remote_id')
    remote_version = request.form.get('remote_version')

    """ Debugging info
    current_app.logger.debug("agents_config_save agent_id: %s",agent_id)
    current_app.logger.debug("agents_config_save server_name: %s",server_name)
    current_app.logger.debug("agents_config_save server_ip: %s",server_ip)
    current_app.logger.debug("agents_config_save remote_id_like: %s",remote_id_like)
    current_app.logger.debug("agents_config_save remote_id: %s",remote_id)
    current_app.logger.debug("agents_config_save remote_version: %s",remote_version)
    """

    try:
        # Save modify agent data
        result = current_app.db.agents.update_one(
            {"_id": ObjectId(agent_id)},
            {"$set": {
                "server_name": server_name,
                "server_ip": server_ip,
                "remote_id_like": remote_id_like,
                "remote_id": remote_id,
                "remote_version": remote_version
            }}
        )
    
    # If an error occurs save modify agent data
    except Exception as e:
        return jsonify({"result": "fail", "message": "Failed to update agent data."})
    
    """ Debugging info
    current_app.logger.info("result: %s",result)
    """

    # If modified count is not 0
    if result.modified_count > 0:
        return jsonify({"result": "success", "message": "Agent data updated successfully!"})
    
    else:
        return jsonify({"result": "fail", "message": "Failed to update agent data."})


@bp.route('get_script_names', methods=['GET']) # /admin/api/agent_manager/get_script_names
def get_script_names():
    """ remote server에게 script file을 전송하기 위해 저장된 script file을 리턴 """

    base_path = "Vulnerability_Check_Script"
    os_types = ["CentOS", "Fedora", "Rocky", "Ubuntu"]
    script_names = []

    try:
        for os_type in os_types:
            for script_name in os.listdir(os.path.join(base_path, os_type)):
                script_names.append({"name": script_name, "os_type": os_type})

        return jsonify(script_names)

    except Exception as e:
        return jsonify({"error": str(e)}), 500



@bp.route('send_script', methods=['POST']) # /admin/api/agent_manager/send_script
def send_script():
    script_name = request.form.get('script_name')
    os_type = request.form.get('os_type')
    agent_id = request.form.get('agent_id')
    current_app.logger.debug("Script Name: %s", script_name)
    current_app.logger.debug("OS Type: %s", os_type)
    current_app.logger.debug("Agent _id: %s", agent_id)

    agent_entry = current_app.db.agents.find_one({"_id": ObjectId(agent_id)})
    if not agent_entry:
        return jsonify({"result": "error", "message": "Agent not found in the database"})
    agent_ip = agent_entry['server_ip']

    script_directory = os.path.join('Vulnerability_Check_Script', os_type)
    script_path = os.path.join(script_directory, script_name)

    # SSL context setup
    context, error_message = create_ssl_context()
    if error_message:
        current_app.logger.error(error_message)
        return jsonify({"result": "fail", "message": "Error loading cert file"})

    # File sending logic starts here
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            secure_conn = context.wrap_socket(s)
            secure_conn.connect((agent_ip, socket_port))
            secure_conn.sendall(b'SEND_SCRIPT')
            file_size = os.path.getsize(script_path)
            secure_conn.sendall(str(file_size).encode('utf-8'))
            if secure_conn.recv(1024) == b'READY':
                with open(script_path, 'rb') as f:
                    while True:
                        data = f.read(4096)
                        if not data:
                            break
                        secure_conn.sendall(data)
                if secure_conn.recv(1024) == b'SUCCESS':

                    # Save script info in mongodb.agents
                    result = current_app.db.agents.update_one( {"_id": ObjectId(agent_id)},
                            {"$set": {
                                "saved_script_os": os_type,
                                "saved_script_file": script_name
                            }}
                        )
        
                    # If an successful in the insert mongodb
                    if result is not None:
                        return jsonify({"result": "success", "message": "Script sent successfully!"})
                    
                    # If an error occurs in the insert mongodb
                    else:
                        return jsonify({"result" : "fail", "message": "MongoDB ERROR"})


                else:
                    return jsonify({"result": "error", "message": "Failed to send script."})
            else:
                return jsonify({"result": "error", "message": "Agent did not respond."})
    except Exception as e:  
        current_app.logger.error(f"Error while sending script: {e}")
        return jsonify({"result": "error", "message": f"Exception encountered: {e}"})


@bp.route('run_script', methods=['POST']) # /admin/api/agent_manager/run_script
def run_script():
    pass

@bp.route('disconnect_agent', methods=['POST'])
def disconnect_agent():
    """ Disconnect Agent and Delete Agent info in mongodb """
    agent_id = request.form.get('agent_id')
    
    # Get agent ip in mongodb.agents
    agent_entry = current_app.db.agents.find_one({"_id": ObjectId(agent_id)})
    
    if not agent_entry:
        return jsonify({"result": "error", "message": "Agent not found in the database"})

    agent_ip = agent_entry['server_ip']

    # Create ssl context
    context, error_message = create_ssl_context() #defined utils.py
    if error_message:
        return jsonify({"result" : "fail", "message" : "Error loading cert file"})

    # Send 'DISCONNECT' to agent
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            secure_socket = context.wrap_socket(s)
            secure_socket.connect((agent_ip, socket_port))
            secure_socket.sendall(b'DISCONNECT')
            data = secure_socket.recv(1024)

    except Exception as e:
        current_app.db.agents.delete_one({"_id": ObjectId(agent_id)})
        return jsonify({"result" : "success", "message" : "Agent removed from the database"})

    # If disconnect was successful, remove the agent from the database
    if data.decode('utf-8') == 'DISCONNECT_OK':
        current_app.db.agents.delete_one({"_id": ObjectId(agent_id)})
        return jsonify({"result" : "success", "message" : "Agent disconnected and removed from the database"})
    
    else:
        return jsonify({"result" : "fail", "message" : "Failed to disconnect agent"})