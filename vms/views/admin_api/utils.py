import re
import socket
import ssl
import os

def is_valid_ip(ip_address):
    """IP 유효성 검사"""
    pattern = r"^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$"
    return re.match(pattern, ip_address)

def create_secure_socket(ip, port, cert_path):
    """SSL 소켓 생성 및 연결"""
    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    context.load_verify_locations(cert_path)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    secure_socket = context.wrap_socket(s)
    secure_socket.connect((ip, port))
    return secure_socket

def create_ssl_context():
    """SSL 컨텍스트 생성 및 PEM 파일 로드. 에러 발생 시 에러 메시지 반환."""
    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    try:
        BASE_DIR = os.path.dirname(os.path.abspath(__file__))
        CERT_PATH = os.path.join(BASE_DIR, '../../secure_shell_key/cert.pem')
        context.load_verify_locations(CERT_PATH)
    except Exception as e:
        error_message = f"Error loading cert file: {e}"
        return None, error_message
    return context, None

def is_valid_server_name(server_name, min_length=2, max_length=16):
    """서버 이름 길이 검증"""
    return min_length <= len(server_name) <= max_length

def parse_os_info(data):
    """OS 정보 파싱"""
    lines = data.split('\n')
    info = {}
    for line in lines:
        if line.startswith('NAME='):
            info['name'] = line.split('=')[1].replace('"', '').strip()
        elif line.startswith('VERSION='):
            info['version'] = line.split('=')[1].replace('"', '').strip()
        elif line.startswith('ID='):
            info['id'] = line.split('=')[1].strip()
        elif line.startswith('ID_LIKE='):
            info['id_like'] = line.split('=')[1].strip()
    return info