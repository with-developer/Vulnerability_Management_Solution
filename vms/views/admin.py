from flask import Blueprint, render_template, request, jsonify, current_app
from .check_auth import token_required
import socket
import ssl
import os
from bson.objectid import ObjectId
from bson.errors import InvalidId
import re
from datetime import datetime

bp = Blueprint('admin', __name__, url_prefix='/admin')

@bp.route('/')
@token_required
def admin(current_user):

    # TODO: client connecting info modify function
    return render_template("admin.html")


def parse_os_info(data):
    lines = data.split('\n')
    info = {}
    for line in lines:
        if line.startswith('NAME='):
            info['name'] = line.split('=')[1].replace('"', '').strip()
        elif line.startswith('VERSION='):
            info['version'] = line.split('=')[1].replace('"', '').strip()
        elif line.startswith('ID='):
            info['id'] = line.split('=')[1].strip()
        elif line.startswith('ID_LIKE='):
            info['id_like'] = line.split('=')[1].strip()
    return info

@bp.route('/api/agent_connect', methods=['POST'])
def agent_connect():
    #TODO: server and client connecting functin
    #1. Get connecting info: OK
    #2. Connecting Test: OK
    #3. Connect Successful OK
    #3.1. mongo DB Insert OK
    #3.2. return Successful OK
    #4. Connect Fail: OK
    #4.1. return Fail: OK
    server_name = request.form.get('server_name')
    # server_name 문자열 길이 검증
    if len(server_name) <= 1 or len(server_name) >= 16:
        return jsonify({"result" : "fail", "message" : "Please provide a server name between 2 to 15 characters."})

    remote_ip = request.form.get('server_ip')
    # remote_ip 유효성 검증
    pattern = r"^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$"
    if not re.match(pattern, remote_ip):
        return jsonify({"result" : "fail", "message" : "The IP address is not valid"})
    
    remote_port = 13469

    current_app.logger.info("Received server_name: %s", server_name)
    current_app.logger.info("Received server_ip: %s", remote_ip)

    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    try:
        BASE_DIR = os.path.dirname(os.path.abspath(__file__))  # This gets the directory of the currently executing script
        CERT_PATH = os.path.join(BASE_DIR, '../secure_shell_key/cert.pem')
        context.load_verify_locations(CERT_PATH)
    except Exception as e:
        current_app.logger.error(f"Error loading cert file: {e}")
        return jsonify({"result" : "fail", "message" : "Error loading cert file"})

    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            secure_socket = context.wrap_socket(s)
            secure_socket.connect((remote_ip, remote_port))
            secure_socket.sendall(b'CONNECT_TEST')
            data = secure_socket.recv(1024)
            current_app.logger.info("Received: %s",data.decode('utf-8'))
    except Exception as e:
        current_app.logger.error(f"Error connect fail: {e}")
        return jsonify({"result" : "fail", "message" : "Error connect fail"})


    if data.decode('utf-8') == 'CONNECT_SUCCESSFUL':
        #ip_hash = hashlib.sha256(remote_ip.encode('utf-8')).hexdigest()
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                secure_socket = context.wrap_socket(s)
                secure_socket.connect((remote_ip, remote_port))
                secure_socket.sendall(b'GET_INFO')
                remote_info = secure_socket.recv(1024)
                current_app.logger.info("Received: %s",remote_info.decode('utf-8'))
                if remote_info.decode('utf-8') == 'unknown':
                    # remote_info값이 unknown이라면
                    remote_name = 'Unknown'
                    remote_version = 'Unknown'
                    remote_id = 'Unknown'
                    remote_id_like = 'Unknown'
                else:
                    info = parse_os_info(remote_info.decode('utf-8'))
                    remote_name = info.get('name', 'Unknown')
                    remote_version = info.get('version', 'Unknown')
                    remote_id = info.get('id', 'Unknown')
                    remote_id_like = info.get('id_like', 'Unknown')

        except Exception as e:
            current_app.logger.error(f"Error: get info fail: {e}")
            return jsonify({"result" : "fail", "message" : "Error connect fail"})
        
        result = current_app.db.agents.insert_one({'server_ip': remote_ip, 'server_name': server_name, 'remote_name':remote_name, 'remote_version':remote_version,'remote_id':remote_id, 'remote_id_like':remote_id_like})
        if result is not None:
            return jsonify({"result" : "success", "message" : "Connecting Successful"})
        else:
            return jsonify({"result" : "fail", "message": "MongoDB ERROR"})
    else:
        return jsonify({"result" : "fail", "message" : "Connecting Fail"})
    

@bp.route('/api/agents_config', methods=['GET'])
def agents_config():
    agent_id = request.args.get('agent_id')
    current_app.logger.info("agent_id: %s", agent_id)
    
    try:
        agent = current_app.db.agents.find_one({"_id": ObjectId(agent_id)})
        current_app.logger.info("agent: %s", agent)
        if agent:
            # Convert ObjectId to string
            agent['_id'] = str(agent['_id'])
            return jsonify(agent)
        else:
            return jsonify({"error": "Agent not found", "error_code":"404"}), 404
    except InvalidId:
        return jsonify({"error": "Invalid agent ID format", "error_code":"400"}), 400

@bp.route('/api/agents_config_save', methods=['POST'])
def agents_config_save():
    # 1. Post data receive
    agent_id = request.form.get('agent_id')
    server_name = request.form.get('server_name')
    if len(server_name) <= 1 or len(server_name) >= 16:
        return jsonify({"result" : "fail", "message" : "Please provide a server name between 2 to 15 characters."})
    
    server_ip = request.form.get('server_ip')
    remote_id_like = request.form.get('remote_id_like')
    remote_id = request.form.get('remote_id')
    remote_version = request.form.get('remote_version')

    # 2. Update MongoDB
    current_app.logger.debug("agents_config_save agent_id: %s",agent_id)
    result = current_app.db.agents.update_one(
        {"_id": ObjectId(agent_id)},
        {"$set": {
            "server_name": server_name,
            "server_ip": server_ip,
            "remote_id_like": remote_id_like,
            "remote_id": remote_id,
            "remote_version": remote_version
        }}
    )
    current_app.logger.info("result: %s",result)
    # 3. return success or fail message
    if result.modified_count > 0:
        return jsonify({"result": "success", "message": "Agent data updated successfully!"})
    else:
        return jsonify({"result": "fail", "message": "Failed to update agent data."})


@bp.route('/api/get_script_names', methods=['GET'])
def get_script_names():
    base_path = "Vulnerability_Check_Script"
    os_types = ["CentOS", "Fedora", "Rocky", "Ubuntu"]

    script_names = []

    try:
        for os_type in os_types:
            for script_name in os.listdir(os.path.join(base_path, os_type)):
                script_names.append(script_name)

        return jsonify(script_names)

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@bp.route('/load_agents')
def load_agents():
    #TODO: View connecting agnets
    #1. View all connecting agents OK
    #2. Add pagenation function OK
    #3. insert last scan info 
    #4. config button link OK
    #5. Add script run button

    
    page = request.args.get('page', 1, type=int)
    per_page = 10  # 한 페이지에 표시될 데이터의 개수
    total_agents = current_app.db.agents.count_documents({})
    total_pages = (total_agents // per_page) + (1 if total_agents % per_page != 0 else 0)

    agents_info = current_app.db.agents.find().skip((page-1)*per_page).limit(per_page)
    return render_template('connect_agent.html', agents=agents_info, total_pages=total_pages, current_page=page)



@bp.route('/load_script')
def load_script():
    base_path = "Vulnerability_Check_Script"
    os_types = ["CentOS", "Fedora", "Rocky", "Ubuntu"]

    scripts = {}

    for os_type in os_types:
        file_paths = [os.path.join(base_path, os_type, f) for f in os.listdir(os.path.join(base_path, os_type))]
        
        file_data = [{
            'name': os.path.basename(f), 
            'size': os.path.getsize(f),
            'last_modified': datetime.fromtimestamp(os.path.getmtime(f)).strftime('%Y-%m-%d %H:%M:%S')
        } for f in file_paths]

        # sort last_modify
        sorted_data = sorted(file_data, key=lambda x: x['last_modified'], reverse=True)
        scripts[os_type] = sorted_data

    return render_template('script_manager.html', scripts=scripts)




@bp.route('/api/get_script', methods=['GET'])
def get_script_content():
    os_type = request.args.get('os_type')
    script_name = request.args.get('script_name')

    # script path setting
    script_path = os.path.join('Vulnerability_Check_Script', os_type, script_name)

    try:
        # read script file
        with open(script_path, 'r') as file:
            content = file.read()
        
        # return script content
        return content

    except FileNotFoundError:
        return jsonify({"error": "Script not found"}), 404

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@bp.route('/api/save_script', methods=['POST'])
def save_script():
    try:
        os_type = request.form.get('os_type')
        script_name = request.form.get('script_name')
        content = request.form.get('content')

        # delete datetime info
        script_name = re.sub(r"_\d{14}\.sh$", ".sh", script_name)

        # add now time
        current_time = datetime.now().strftime('%Y%m%d%H%M%S')
        new_script_name = f"{script_name.rsplit('.', 1)[0]}_{current_time}.sh"

        base_path = "Vulnerability_Check_Script"
        script_path = os.path.join(base_path, os_type, new_script_name)
        current_app.logger.debug("script_path: %s",script_path)

        # script save
        try:
            with open(script_path, 'w') as f:
                f.write(content)
        except Exception as e:
            current_app.logger.error(f"Error writing to file: {script_path}. Error: {str(e)}")
            return jsonify(result="fail", message=f"Error: {str(e)}"), 500

        return jsonify(result="success", message="Script saved successfully!"), 200

    except Exception as e:
        return jsonify(result="fail", message=f"Error: {str(e)}"), 500

@bp.route('/api/rename_script', methods=['POST'])
def rename_script():
    base_path = "Vulnerability_Check_Script"
    
    # Get data from the request
    os_type = request.form.get('os_type')
    old_script_name = request.form.get('old_script_name')
    new_script_name = request.form.get('new_script_name')
    
    # Check if the new script name has the correct format
    if not new_script_name.endswith('.sh') or '/' in new_script_name:
        return jsonify(result="error", message="Invalid script name. Script name should end with '.sh' and should not contain '/'."), 400

    # Paths for the old and new script
    old_script_path = os.path.join(base_path, os_type, old_script_name)
    new_script_path = os.path.join(base_path, os_type, new_script_name)
    
    try:
        # Check if the old script exists
        if not os.path.exists(old_script_path):
            return jsonify(result="error", message=f"Script '{old_script_name}' does not exist."), 404
        
        # Check if a script with the new name already exists
        if os.path.exists(new_script_path):
            return jsonify(result="error", message=f"A script with the name '{new_script_name}' already exists."), 400
        
        # Rename the script
        os.rename(old_script_path, new_script_path)
        
        return jsonify(result="success", message=f"Script '{old_script_name}' renamed to '{new_script_name}' successfully.")
    
    except Exception as e:
        # Handle any other unforeseen errors
        return jsonify(result="error", message=str(e)), 500


@bp.route('/api/delete_script', methods=['POST'])
def delete_script():
    base_path = "Vulnerability_Check_Script"
    
    # Get data from the request
    os_type = request.form.get('os_type')
    script_name = request.form.get('script_name')

    # Build and normalize the script path
    script_path = os.path.normpath(os.path.join(base_path, os_type, script_name))
    
    # Validate that the path is still within the base directory
    if not os.path.commonprefix([script_path, base_path]) == base_path:
        return jsonify(result="error", message="Invalid file path."), 400

    try:
        # Check if the script exists
        if not os.path.exists(script_path):
            return jsonify(result="error", message=f"Script '{script_name}' does not exist."), 404
        
        # Delete the script
        os.remove(script_path)
        
        return jsonify(result="success", message=f"Script '{script_name}' deleted successfully.")
    
    except Exception as e:
        # Handle any other unforeseen errors
        return jsonify(result="error", message=str(e)), 500


@bp.route('/loadC')
def load_c():
    return render_template('c_content.html')