import socket
import subprocess
import ssl

HOST = '0.0.0.0'
PORT = 13469

# 취약점 진단 스크립트를 실행하고, 결과를 리턴하는 함수
def execute_script():
    try:
        result = subprocess.check_output(['./Ubuntu_Script.sh'], stderr=subprocess.STDOUT, shell=True)
        return result.decode('utf-8')
    except subprocess.CalledProcessError as e:
        # 에러 발생시 에러 메세지를 리턴
        return e.output.decode('utf-8')

# agent를 사용하는 서버의 정보를 리턴하는 함수
def get_info():
    try:
        result = subprocess.check_output(['cat', '/etc/os-release'], stderr=subprocess.STDOUT)
        return result.decode('utf-8')
    except subprocess.CalledProcessError as e:
        # cat /etc/os-release 명령어가 실행되지 않을 경우 unknown이라는 메세지가 리턴되고, 사용자가 수동으로 정보를 입력해야함
        return 'unknown'
    
def save_received_file(secure_conn, file_name, expected_file_size):
    try:
        with open(file_name, 'wb') as f:
            total_received = 0
            while total_received < expected_file_size:
                chunk = secure_conn.recv(4096)
                if not chunk:
                    break
                total_received += len(chunk)
                f.write(chunk)
        return True
    except:
        return False

context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
context.load_cert_chain('cert.pem', 'key.pem')
# SSL 통신

while(True):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind((HOST, PORT))
        s.listen()
        print(f"[*] Listening on {HOST}:{PORT}")
        
        while True:
            conn, addr = s.accept()
            with context.wrap_socket(conn, server_side=True) as secure_conn:
                print(f"[*] Connected by {addr}")
                
                data = secure_conn.recv(1024)
                if data.decode('utf-8') == 'RUN':
                    response = execute_script()
                    secure_conn.sendall(response.encode('utf-8'))
                elif data.decode('utf-8') == 'CONNECT_TEST':
                    response = 'CONNECT_SUCCESSFUL'
                    secure_conn.sendall(response.encode('utf-8'))
                elif data.decode('utf-8') == 'GET_INFO':
                    response = get_info()
                    secure_conn.sendall(response.encode('utf-8'))
                elif data.decode('utf-8') == 'SEND_SCRIPT':
                    file_size = int(secure_conn.recv(1024).decode('utf-8'))
                    secure_conn.sendall(b'READY')  # Signal the server that we are ready to receive the file
                    success = save_received_file(secure_conn, 'Vulnerability_scan.sh', file_size)
                    if success:
                        secure_conn.sendall(b'SUCCESS')
                    else:
                        secure_conn.sendall(b'ERROR')
