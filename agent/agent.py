import socket
import subprocess
import ssl
import os
import threading

HOST = '0.0.0.0'
PORT = 13469

def execute_script():
    try:
        result = subprocess.check_output(['./Vulnerability_scan.sh'], stderr=subprocess.STDOUT, shell=True)
        return result.decode('utf-8')
    except subprocess.CalledProcessError as e:
        return e.output.decode('utf-8')

def get_info():
    try:
        result = subprocess.check_output(['cat', '/etc/os-release'], stderr=subprocess.STDOUT)
        return result.decode('utf-8')
    except subprocess.CalledProcessError:
        return 'unknown'
    
def save_received_file(secure_conn, file_name, expected_file_size):
    try:
        with open(file_name, 'wb') as f:
            total_received = 0
            while total_received < expected_file_size:
                chunk = secure_conn.recv(4096)
                if not chunk:
                    break
                total_received += len(chunk)
                f.write(chunk)

        try:
            os.chmod(file_name, 0o755)
        except Exception as e:
            print(f"Error changing permissions of {file_name}: {e}")
            return False

        return True
    except Exception as e:
        print(f"Error while saving file: {e}")
        return False

def disconnect(secure_conn=None):
    if secure_conn:
        response = 'DISCONNECT_OK'
        secure_conn.sendall(response.encode('utf-8'))
    print("[*] Disconnecting agent and shutting down.")
    exit(0)

def listen_for_exit():
    while True:
        user_input = input("Enter a command (type 'exit' to shutdown the agent): ")
        if user_input.strip().lower() == 'exit':
            disconnect()



##### Main Code Start #####

context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
try:
    context.load_cert_chain('cert.pem', 'key.pem')
except Exception as e:
    print(f"Error loading SSL certificates: {e}")
    exit(1)

# 별도의 스레드에서 사용자의 입력을 대기
exit_thread = threading.Thread(target=listen_for_exit)
exit_thread.daemon = True  # 메인 프로그램이 종료될 때 함께 종료
exit_thread.start()

while True:
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.bind((HOST, PORT))
            s.listen()
            print(f"[*] Listening on {HOST}:{PORT}")

            while True:
                conn, addr = s.accept()
                with context.wrap_socket(conn, server_side=True) as secure_conn:
                    print(f"[*] Connected by {addr}")

                    data = secure_conn.recv(1024)
                    if not data:
                        break

                    if data.decode('utf-8') == 'RUN':
                        response = execute_script()
                        secure_conn.sendall(response.encode('utf-8'))
                    elif data.decode('utf-8') == 'CONNECT_TEST':
                        response = 'CONNECT_SUCCESSFUL'
                        secure_conn.sendall(response.encode('utf-8'))
                    elif data.decode('utf-8') == 'GET_INFO':
                        response = get_info()
                        secure_conn.sendall(response.encode('utf-8'))
                    elif data.decode('utf-8') == 'SEND_SCRIPT':
                        try:
                            file_size = int(secure_conn.recv(1024).decode('utf-8'))
                        except ValueError:
                            print("Received invalid file size")
                            continue

                        secure_conn.sendall(b'READY')
                        success = save_received_file(secure_conn, 'Vulnerability_scan.sh', file_size)
                        if success:
                            secure_conn.sendall(b'SUCCESS')
                        else:
                            secure_conn.sendall(b'ERROR')
                    elif data.decode('utf-8') == 'DISCONNECT':
                        disconnect(secure_conn)
                    

    except Exception as e:
        print(f"Error occurred: {e}")
