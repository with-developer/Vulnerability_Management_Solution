import socket
import subprocess
import ssl

HOST = '0.0.0.0'
PORT = 13469

# 취약점 진단 스크립트를 실행하고, 결과를 리턴하는 함수
def execute_script():
    try:
        result = subprocess.check_output(['./Ubuntu_Script.sh'], stderr=subprocess.STDOUT, shell=True)
        return result.decode('utf-8')
    except subprocess.CalledProcessError as e:
        # 에러 발생시 에러 메세지를 리턴
        return e.output.decode('utf-8')

# agent를 사용하는 서버의 정보를 리턴하는 함수
def get_info():
    try:
        result = subprocess.check_output(['cat', '/etc/os-release'], stderr=subprocess.STDOUT)
        return result.decode('utf-8')
    except subprocess.CalledProcessError as e:
        # cat /etc/os-release 명령어가 실행되지 않을 경우 unknown이라는 메세지가 리턴되고, 사용자가 수동으로 정보를 입력해야함
        return 'unknown'

context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
context.load_cert_chain('cert.pem', 'key.pem')
# SSL 통신

while(True):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind((HOST, PORT))
        s.listen()
        print(f"[*] Listening on {HOST}:{PORT}")
        
        while True:
            conn, addr = s.accept()
            with context.wrap_socket(conn, server_side=True) as secure_conn:
                print(f"[*] Connected by {addr}")
                
                data = secure_conn.recv(1024)
                if data.decode('utf-8') == 'RUN':
                    response = execute_script()
                    secure_conn.sendall(response.encode('utf-8'))
                elif data.decode('utf-8') == 'CONNECT_TEST':
                    response = 'CONNECT_SUCCESSFUL'
                    secure_conn.sendall(response.encode('utf-8'))
                elif data.decode('utf-8') == 'GET_INFO':
                    response = get_info()
                    secure_conn.sendall(response.encode('utf-8'))
